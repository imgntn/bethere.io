<html>
<head>
	<script src="build/Three.js"></script>
	<script src="jquery-1.7.2.js"></script>
	<script src="Tween.js"></script>
	<script src="Tree.js"></script>
	<script src='threex.domevent.js'></script>
	<script src='threex.domevent.object3d.js'></script>
	<script src="../threex/threex.fullscreen.js"></script>
	<script src="../threex/THREEx.KeyboardState.js"></script>
		<script src='../threex/THREEx.WindowResize.js'></script>
	<script src="audiolet/audiolet/Audiolet.js"></script>
	<script src="audiolet_util.js"></script>
	<script src="audiolet_testapp.js"></script>


</head>
<body>
	<button class="button request">request fullscreen</button>
	<script id ='utility_fullscreen'>
	THREEx.FullScreen.bindKey({
				dblclick	: true
			});

			document.querySelector(".button.request").addEventListener('click', function(){
				THREEx.FullScreen.request();
			}, false);
	</script>
	
	
	<script id="fragmentShader" type="x-shader/x-fragment">

		//
		// Description : Array and textureless GLSL 3D simplex noise function.
		//      Author : Ian McEwan, Ashima Arts.
		//  Maintainer : ijm
		//     Lastmod : 20110409 (stegu)
		//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.
		//               Distributed under the MIT License. See LICENSE file.
		//

		uniform float time;

		varying vec3 vTexCoord3D;
		varying vec3 vNormal;
		varying vec3 vViewPosition;

		vec4 permute( vec4 x ) {

			return mod( ( ( x * 34.0 ) + 1.0 ) * x, 289.0 );

		}

		vec4 taylorInvSqrt( vec4 r ) {

			return 1.79284291400159 - 0.85373472095314 * r;

		}

		float snoise( vec3 v ) {

			const vec2 C = vec2( 1.0 / 6.0, 1.0 / 3.0 );
			const vec4 D = vec4( 0.0, 0.5, 1.0, 2.0 );

			// First corner

			vec3 i  = floor( v + dot( v, C.yyy ) );
			vec3 x0 = v - i + dot( i, C.xxx );

			// Other corners

			vec3 g = step( x0.yzx, x0.xyz );
			vec3 l = 1.0 - g;
			vec3 i1 = min( g.xyz, l.zxy );
			vec3 i2 = max( g.xyz, l.zxy );

			//  x0 = x0 - 0. + 0.0 * C
			vec3 x1 = x0 - i1 + 1.0 * C.xxx;
			vec3 x2 = x0 - i2 + 2.0 * C.xxx;
			vec3 x3 = x0 - 1. + 3.0 * C.xxx;

			// Permutations

			i = mod( i, 289.0 );
			vec4 p = permute( permute( permute(
					 i.z + vec4( 0.0, i1.z, i2.z, 1.0 ) )
				   + i.y + vec4( 0.0, i1.y, i2.y, 1.0 ) )
				   + i.x + vec4( 0.0, i1.x, i2.x, 1.0 ) );

			// Gradients
			// ( N*N points uniformly over a square, mapped onto an octahedron.)

			float n_ = 1.0 / 7.0; // N=7

			vec3 ns = n_ * D.wyz - D.xzx;

			vec4 j = p - 49.0 * floor( p * ns.z *ns.z );  //  mod(p,N*N)

			vec4 x_ = floor( j * ns.z );
			vec4 y_ = floor( j - 7.0 * x_ );    // mod(j,N)

			vec4 x = x_ *ns.x + ns.yyyy;
			vec4 y = y_ *ns.x + ns.yyyy;
			vec4 h = 1.0 - abs( x ) - abs( y );

			vec4 b0 = vec4( x.xy, y.xy );
			vec4 b1 = vec4( x.zw, y.zw );

			vec4 s0 = floor( b0 ) * 2.0 + 1.0;
			vec4 s1 = floor( b1 ) * 2.0 + 1.0;
			vec4 sh = -step( h, vec4( 0.0 ) );

			vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;
			vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;

			vec3 p0 = vec3( a0.xy, h.x );
			vec3 p1 = vec3( a0.zw, h.y );
			vec3 p2 = vec3( a1.xy, h.z );
			vec3 p3 = vec3( a1.zw, h.w );

			// Normalise gradients

			vec4 norm = taylorInvSqrt( vec4( dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3) ) );
			p0 *= norm.x;
			p1 *= norm.y;
			p2 *= norm.z;
			p3 *= norm.w;

			// Mix final noise value

			vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3) ), 0.0 );
			m = m * m;
			return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),
										dot(p2,x2), dot(p3,x3) ) );

		}

		float heightMap( vec3 coord ) {

			float n = abs( snoise( coord ) );

			n += 0.25   * abs( snoise( coord * 2.0 ) );
			n += 0.25   * abs( snoise( coord * 4.0 ) );
			n += 0.125  * abs( snoise( coord * 8.0 ) );
			n += 0.0625 * abs( snoise( coord * 16.0 ) );

			return n;

		}

		void main( void ) {

			// height

			float n = heightMap( vTexCoord3D );

			// color

			gl_FragColor = vec4( vec3( 1.5 - n, 1.0 - n, 0.5 - n ), 1.0 );

			// normal

			const float e = 0.001;

			float nx = heightMap( vTexCoord3D + vec3( e, 0.0, 0.0 ) );
			float ny = heightMap( vTexCoord3D + vec3( 0.0, e, 0.0 ) );
			float nz = heightMap( vTexCoord3D + vec3( 0.0, 0.0, e ) );

			vec3 normal = normalize( vNormal + 0.05 * vec3( n - nx, n - ny, n - nz ) / e );

			// diffuse light

			vec3 vLightWeighting = vec3( 0.1 );

			vec4 lDirection = viewMatrix * vec4( normalize( vec3( 1.0, 0.0, 0.5 ) ), 0.0 );
			float directionalLightWeighting = dot( normal, normalize( lDirection.xyz ) ) * 0.25 + 0.75;
			vLightWeighting += vec3( 1.0 ) * directionalLightWeighting;

			// specular light

			vec3 dirHalfVector = normalize( lDirection.xyz + normalize( vViewPosition ) );

			float dirDotNormalHalf = dot( normal, dirHalfVector );

			float dirSpecularWeight = 0.0;
			if ( dirDotNormalHalf >= 0.0 )
				dirSpecularWeight = ( 1.0 - n ) * pow( dirDotNormalHalf, 5.0 );

			vLightWeighting += vec3( 1.0, 0.5, 0.0 ) * dirSpecularWeight * n * 2.0;

			gl_FragColor *= vec4( vLightWeighting, 1.0 );

		}

	</script>

	<script id="vertexShader" type="x-shader/x-vertex">

		uniform float time;
		uniform float scale;

		varying vec3 vTexCoord3D;
		varying vec3 vNormal;
		varying vec3 vViewPosition;

		void main( void ) {

			vec4 mPosition = objectMatrix * vec4( position, 1.0 );
			vNormal = normalize( normalMatrix * normal );
			vViewPosition = cameraPosition - mPosition.xyz;

			vTexCoord3D = scale * ( position.xyz + vec3( 0.0, 0.0, -time ) );
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}

	</script>
	
	<!--This is where we load the island and the objects specific to it-->
	<script src="loadobjects_island1.js"></script>
	
	<script>
	var keyboard	= new THREEx.KeyboardState();

		setInterval(function(){
			var key		= "alt+left";
			var pressed	= keyboard.pressed(key);
			console.log("key", key, "pressed", pressed);
		}, 100);
		
	var container = document.createElement( 'div' ),
	width = window.innerWidth,
	height = window.innerHeight,
	camera,
	scene,
	renderer,
	SHADOW_MAP_WIDTH = 2048,
	SHADOW_MAP_HEIGHT = 1024;

	container = document.body.appendChild( container );

	camera = new THREE.PerspectiveCamera( 50, width/height, .5, 7500 );
	// camera.position.set(158.16380101378365,38.91043790588581,-12.913103534540106);
	// camera.rotation.set(-1.191340631445364,1.252132902247305,1.4154706008869091);
	//camera.aspect = width / height;
	camera.updateProjectionMatrix();

	scene = new THREE.Scene();
scene.add(camera);
scene.fog = new THREE.FogExp2( 0x000000, 0.0015 );
	renderer = new THREE.WebGLRenderer( { clearAlpha: 1, clearColor: 0x000000 } );
	renderer.setSize( width, height );
	renderer.shadowCameraNear = 4;
	renderer.shadowCameraFar = this.camera.far;
	renderer.shadowCameraFov = 50;
	renderer.shadowMapBias = 0.0039;
	renderer.shadowMapDarkness = 0.5;
	renderer.shadowMapWidth = SHADOW_MAP_WIDTH;
	renderer.shadowMapHeight = SHADOW_MAP_HEIGHT;
	renderer.shadowMapEnabled = true;
	renderer.shadowMapSoft = true;
	container.appendChild( renderer.domElement );
	
	
	//controls
	
	var controls = new THREE.FirstPersonControls(camera);
	controls.movementSpeed = 100;
	controls.lookSpeed = 0.15;

//lights

	var light1 = new THREE.PointLight();
	light1.intensity = 1;
	light1.castShadow = false;
	light1.color = new THREE.Color().setRGB(0,1,0.14901960784313725);
	light1.position.set(21.472392638036624,150,-2.3391812865496036);
	light1.rotation.set(0,0,0);
	light1.scale.set(1,1,1);
	scene.add( light1 );

	var light2 = new THREE.PointLight();
	light2.intensity = 1;
	light2.castShadow = false;
	light2.color = new THREE.Color().setRGB(0.0196078431372549,0.2980392156862745,1);
	light2.position.set(14.110429447852972,150,-257.30994152046776);
	light2.rotation.set(0,0,0);
	light2.scale.set(1,1,1);
	scene.add( light2 );

	var light3 = new THREE.PointLight();
	light3.intensity = 1;
	light3.castShadow = false;
	light3.color = new THREE.Color().setRGB(1,0.0196078431372549,0.14901960784313725);
	light3.position.set(14.110429447852544,150,152.04678362573108);
	light3.rotation.set(0,0,0);
	light3.scale.set(1,1,1);
	scene.add( light3 );

	var light4 = new THREE.PointLight();
	light4.intensity = 1;
	light4.castShadow = false;
	light4.color = new THREE.Color().setRGB(1,0,0.5);
	light4.position.set(-42.09591474245125,-244.17693169092934,-181.41097424412075);
	light4.rotation.set(0,0,0);
	light4.scale.set(1,1,1);
	scene.add( light4 );
	
	var light5 = new THREE.SpotLight();
	light5.intensity = 1;
	light5.castShadow = true;
	light5.color = new THREE.Color().setRGB(1,1,1);
	light5.position.set(-6.571936056838457,53.69540873460243,0);
	light5.rotation.set(0,0,0);
	light5.scale.set(1,1,1);
	scene.add( light5 );
	
	
	var lightcube1_geometry = new THREE.CubeGeometry(40,40,40);
	lightcube1_material =  new THREE.MeshBasicMaterial( { color: 0xff0000, wireframe: true } );
	lightcube1 = new THREE.Mesh( lightcube1_geometry, lightcube1_material );
	        scene.add( lightcube1 );
	
			var lightcube2_geometry = new THREE.CubeGeometry(40,40,40);
			lightcube2_material =  new THREE.MeshBasicMaterial( { color: 0x00ff00, wireframe: true } );
			lightcube2 = new THREE.Mesh( lightcube2_geometry, lightcube2_material );
			        scene.add( lightcube2 );
			
					var lightcube3_geometry = new THREE.CubeGeometry(40,40,40);
					lightcube3_material =  new THREE.MeshBasicMaterial( { color: 0x0000ff, wireframe: true } );
					lightcube3 = new THREE.Mesh( lightcube3_geometry, lightcube3_material );
					        scene.add( lightcube3 );
					
							var lightcube4_geometry = new THREE.CubeGeometry(40,40,40);
							lightcube4_material =  new THREE.MeshBasicMaterial( { color: 0xff00ff, wireframe: true } );
							lightcube4 = new THREE.Mesh( lightcube4_geometry, lightcube4_material );
							        scene.add( lightcube4 );
							
										var lightcube5_geometry = new THREE.CubeGeometry(40,40,40);
										lightcube5_material =  new THREE.MeshBasicMaterial( { color: 0x00ffff, wireframe: true } );
										lightcube5 = new THREE.Mesh( lightcube5_geometry, lightcube5_material );
										        scene.add( lightcube5 );
	//island 
	var island = createIsland(scene);
/*
	var island_loader = new THREE.JSONLoader();
	island_loader.load( "island1.js", function(island_geometry) {
	var island_material = new THREE.MeshLambertMaterial();
	island_material.color = new THREE.Color().setRGB(1,1,1);
	island_material.ambient = new THREE.Color().setRGB(0.0196078431372549,0.0196078431372549,0.0196078431372549);
	island_material.specular = new THREE.Color().setRGB(0.06666666666666667,0.06666666666666667,0.06666666666666667);
    //island_material.map = THREE.ImageUtils.loadTexture("grass.jpg");


	island = new THREE.Mesh(island_geometry, island_material);
		island.receiveShadow = true;
	island.position.set(0,0,0);
	island.rotation.set(0,0,0);
	island.scale.set(100,100,100);
	scene.add( island );
	});
*/

	//baptistery
var baptistery = createBaptistery(scene);
/*
	var baptistery_loader = new THREE.JSONLoader();
	baptistery_loader.load( "last_baptistery2.js", function(bapstistery_geometry) {
	var baptistery_material = new THREE.MeshLambertMaterial();
	baptistery_material.color = new THREE.Color().setRGB(1,1,1);
	baptistery_material.ambient = new THREE.Color().setRGB(0.0196078431372549,0.0196078431372549,0.0196078431372549);
	baptistery_material.specular = new THREE.Color().setRGB(0.06666666666666667,0.06666666666666667,0.06666666666666667);
//material.map = THREE.ImageUtils.loadTexture("path/to/texture.jpg");
	
	

	baptistery = new THREE.Mesh(bapstistery_geometry, baptistery_material);
	baptistery.position.set(2.4539877300613355,0,-11.695906432748425);
	baptistery.rotation.set(0,-0.84,0);
	baptistery.scale.set(4.5,4.5,4.5);
	baptistery.receiveShadow=true;
	scene.add( baptistery );
	});
*/

//plants
var plant1 = createPlant1(scene);
/*
var loader = new THREE.JSONLoader();
loader.load( "plant1.js", function(plant1_geometry) {
var plant1_material = new THREE.MeshLambertMaterial();
plant1_material.color = new THREE.Color().setRGB(1,1,1);
plant1_material.ambient = new THREE.Color().setRGB(0.0196078431372549,0.0196078431372549,0.0196078431372549);
plant1_material.specular = new THREE.Color().setRGB(0.06666666666666667,0.06666666666666667,0.06666666666666667);
//material.map = THREE.ImageUtils.loadTexture("path/to/texture.jpg");
plant1 = new THREE.Mesh(plant1_geometry, plant1_material);
plant1.position.set(30,10,10);
plant1.rotation.set(0,0,0);
plant1.scale.set(10,10,10);
plant1.castShadow = true;
plant1.receiveShadow = true;
scene.add( plant1 );
});
*/



//fireballsun

var start_time, uniforms, fireballmesh;
var oldTime = new Date().getTime();

	start_time = new Date().getTime();

	uniforms = {
		time: 	{ type: "f", value: 1.0 },
		scale: 	{ type: "f", value: 1.5 }
	};
		var size = 0.75;
		
			var fireballmaterial = new THREE.ShaderMaterial( {

				uniforms: uniforms,
				vertexShader: document.getElementById( 'vertexShader' ).textContent,
				fragmentShader: document.getElementById( 'fragmentShader' ).textContent

			} );
			
			fireballmesh = new THREE.Mesh( new THREE.SphereGeometry( size, 64, 32 ), fireballmaterial );
			scene.add( fireballmesh );
fireballmesh.position.set(1000,300,100);
fireballmesh.scale = new THREE.Vector3(150,150,150);

//DOMevents in 3D

var domEvent;
var mouse = { x: 0, y: 0 };

var attachmentA, attachmentB, attachmentC, attachmentD, attachmentE, attachmentF;

THREE.Object3D._threexDomEvent.camera(camera);
	
	new THREE.JSONLoader().load('attachmentpoint2.js', function(geometry){
		var meshes = createAttachments(scene, geometry);//buildMeshes(geometry);
		bindEvents(meshes);
		attachmentA = meshes['attachmentA'];
		attachmentB = meshes['attachmentB'];
		attachmentC = meshes['attachmentC'];
		attachmentD = meshes['attachmentD'];
		attachmentE = meshes['attachmentE'];
		attachmentF = meshes['attachmentF'];
	});


/*
function buildMeshes(geometry){
	var meshes	= {};
	
	var material	= new THREE.MeshLambertMaterial( { color: 0xFF8800 } );
	material.ambient = new THREE.Color().setRGB(0.0196078431372549,0.0196078431372549,0.0196078431372549);
	
	var mesh	= new THREE.Mesh( geometry, material );
	mesh.position.set(-42.62877442273525,2.239641657334812,49.27211646136609);
	mesh.rotation.set(0,-0.84,0);
	mesh.scale= new THREE.Vector3(1,1,1);
	scene.add( mesh );
	meshes['attachmentA']	= mesh;

	var material	= new THREE.MeshLambertMaterial( { color: 0x88CC44 } );
	var mesh	= new THREE.Mesh( geometry, material );
	mesh.position.set(-7.10479573712278,2.2396416573348112,98.5442329227322);
	mesh.rotation.set(0,-0.6283185307179586,-0.06981317007977328);
	mesh.scale= new THREE.Vector3(1,1,1);
	scene.add( mesh );
	meshes['attachmentB']	= mesh;
	
	var material	= new THREE.MeshLambertMaterial( { color: 0x88CC44 } );
	var mesh	= new THREE.Mesh( geometry, material );
	mesh.position.set(55.062166962699706,2.2396416573348112,-47.032474804031594);
	mesh.rotation.set(0,-0.6283185307179586,-0.06981317007977328);
	mesh.scale= new THREE.Vector3(1,1,1);
	scene.add( mesh );
	meshes['attachmentC']	= mesh;

	var material	= new THREE.MeshLambertMaterial( { color: 0x88CC44 } );
	var mesh	= new THREE.Mesh( geometry, material );
	mesh.position.set(-51.50976909413862,2.239641657334812,-47.03247480403115);
	mesh.rotation.set(0,0.13962634015954656,0);
	mesh.scale= new THREE.Vector3(1,1,1);
	scene.add( mesh );
	meshes['attachmentD']	= mesh;
	
	var material	= new THREE.MeshLambertMaterial( { color: 0x88CC44 } );
	var mesh	= new THREE.Mesh( geometry, material );
	mesh.position.set(39.07637655417396,2.239641657334812,47.032474804031395);
	mesh.rotation.set(0,0.13962634015954656,0);
	mesh.scale= new THREE.Vector3(1,1,1);
	scene.add( mesh );
	meshes['attachmentE']	= mesh;
	
	var material	= new THREE.MeshLambertMaterial( { color: 0x88CC44 } );
	var mesh	= new THREE.Mesh( geometry, material );
	mesh.position.set(-1.77619893428081,2.239641657334812,-100.7838745800672);
	mesh.rotation.set(0,-2.303834612632515,0);
	mesh.scale= new THREE.Vector3(1,1,1);
	scene.add( mesh );
	meshes['attachmentF'] = mesh;

	return meshes;	
}*/

/*----callback functions----*/

var cbScale = function(object3d) {
	var scale	= 20;
	new TWEEN.Tween(object3d.scale)
		.to({x: scale, y: scale, z: scale}, 1000)
		.easing(TWEEN.Easing.Quartic.EaseIn)
		.start();
	new TWEEN.Tween(object3d.material.color)
		.to({r: 1, g: 0.5, b: 0}, 100)
		.easing(TWEEN.Easing.Quartic.EaseIn)
		.start();
};
cbScale.off = function(object3d) {
	var scale	= 1;
	new TWEEN.Tween(object3d.scale)
		.to({x: scale, y: scale, z: scale}, 300)
		.easing(TWEEN.Easing.Quartic.EaseIn)
		.start();
	new TWEEN.Tween(object3d.material.color)
		.to({r: 0.5, g: 0.75, b: 0.25}, 300)
		.easing(TWEEN.Easing.Quartic.EaseIn)
		.start();
}

var cbRotate = function(object3d) {
	if( object3d.rotation.x < Math.PI/4 ){
		var rotation	= {x: Math.PI/2};
		var color	= {r: 1, g: 0.5, b: 0};
	}else{
		var rotation	= {x:0};
		var color	= {r: 0.5, g: 0.75, b: 0.25};
	}
	new TWEEN.Tween(object3d.rotation).to(rotation, 800)
		.easing(TWEEN.Easing.Bounce.EaseOut).start();
	new TWEEN.Tween(object3d.material.color).to(color, 300)
		.easing(TWEEN.Easing.Quartic.EaseIn).start();
};

var cbWTF = function(object3d) {
	new TWEEN.Tween(object3d.scale)
		.to({x: 1.5, y: 1.5, z: 1.5}, 200)
		.easing(TWEEN.Easing.Quartic.EaseIn)
		.start();
	new TWEEN.Tween(object3d.material.color)
		.to({r: 1, g: 0.5, b: 0}, 600)
		.delay(400)
		.easing(TWEEN.Easing.Quartic.EaseIn)
		.start();
	new TWEEN.Tween(object3d.rotation)
		.to({y: 3*Math.PI}, 1000)
		.easing(TWEEN.Easing.Quartic.EaseIn)
		.start();
};
cbWTF.off = function(object3d) {
	new TWEEN.Tween(object3d.scale)
		.to({x: 1, y: 1, z: 1}, 300)
		.easing(TWEEN.Easing.Quartic.EaseOut)
		.start();
	new TWEEN.Tween(object3d.material.color)
		.to({r: 0.5, g: 0.75, b: 0.25}, 600)
		.delay(400)
		.easing(TWEEN.Easing.Quartic.EaseOut)
		.start();
	new TWEEN.Tween(object3d.rotation)
		.to({y: Math.PI}, 1000)
		.easing(TWEEN.Easing.Quartic.EaseOut)
		.start();
};

var cbHelpA = function(event) {
	cbScale(attachmentA);
};
cbHelpA.off = function(event) {
	cbScale.off(attachmentA);
};

var cbHelpB = function(event) {
	cbRotate(attachmentB);
};

var cbHelpC = function(event) {
	cbWTF(attachmentC);
};
cbHelpC.off = function(event) {
	cbWTF.off(attachmentC);
};

var cbHelpD = function(event) {
	cbScale(attachmentD);
};
cbHelpD.off = function(event) {
	cbScale.off(attachmentD);
};

var cbHelpE = function(event) {
	cbRotate(attachmentE);
};

var cbHelpF = function(event) {
	cbWTF(attachmentF);
};
cbHelpF.off = function(event) {
	cbWTF.off(attachmentF);
};

function bindEvents(meshes){
	meshes['attachmentA'].on('click', cbHelpA).on('mouseup', cbHelpA.off);
	meshes['attachmentB'].on('mouseover', cbHelpB);
	meshes['attachmentC'].on('mouseover', cbHelpC).on('mouseout', cbHelpC.off);
	meshes['attachmentD'].on('click', cbHelpD).on('mouseup', cbHelpD.off);
	meshes['attachmentE'].on('mouseover', cbHelpE);
	meshes['attachmentF'].on('mouseover', cbHelpF).on('mouseout', cbHelpF.off);
}

/*----end callback functions----*/

// particles

var particles, geometry, materials = [], parameters, i, h, color;
geometry = new THREE.Geometry();

				for ( i = 0; i < 2000; i ++ ) {

					vector = new THREE.Vector3( Math.random() * 2000 - 1000, Math.random() * 2000 - 1000, Math.random() * 2000 - 1000 );
					geometry.vertices.push( new THREE.Vertex( vector ) );

				}

				parameters = [ [ [1.0, 1.0, 1.0], 5 ], [ [0.95, 1, 1], 4 ], [ [0.90, 1, 1], 3 ], [ [0.85, 1, 1], 2 ], [ [0.80, 1, 1], 1 ] ];
				//parameters = [ [ 0xff0000, 5 ], [ 0xff3300, 4 ], [ 0xff6600, 3 ], [ 0xff9900, 2 ], [ 0xffaa00, 1 ] ];
			//	parameters = [ [ 0xffffff, 5 ], [ 0xdddddd, 4 ], [ 0xaaaaaa, 3 ], [ 0x999999, 2 ], [ 0x777777, 1 ] ];

				for ( i = 0; i < parameters.length; i ++ ) {

					size  = parameters[i][1];
					color = parameters[i][0];

					//materials[i] = new THREE.ParticleBasicMaterial( { color: color, size: size } );

					materials[i] = new THREE.ParticleBasicMaterial( { size: size } );
					materials[i].color.setHSV( color[0], color[1], color[2] );

					particles = new THREE.ParticleSystem( geometry, materials[i] );

					particles.rotation.x = Math.random() * 6;
					particles.rotation.y = Math.random() * 6;
					particles.rotation.z = Math.random() * 6;
					particles.castShadow = true;

					scene.add( particles );

				}
				

// pubsub_selector_plane
// plane
	var pubsubplane_geometry = new THREE.PlaneGeometry( 30, 30 );
	var pubsubplane_material = new THREE.MeshBasicMaterial( { color: 0x0000ff } );
	var pubsubplane = new THREE.Mesh( pubsubplane_geometry, pubsubplane_material );
	pubsubplane.position = new THREE.Vector3(0,60,0)
	pubsubplane.rotation = new THREE.Vector3(4.5,0,0)
	pubsubplane.doubleSided=true;
	pubsubplane.receiveShadow=true;
	pubsubplane.castShadow=true;
	//pubsubplane.castShadow=true;
	scene.add( pubsubplane );


// audio & audiolet

//audiolet variables
var audio, initaudio;
var keyboardFuncs;
var mesh, meshsource;

	
	
		// here you add your objects
		// - you will most likely replace this part by your own
		var geometry_a	= new THREE.CubeGeometry( 10, 10, 10 );
		var material_a	= new THREE.MeshNormalMaterial();
		mesh	= new THREE.Mesh( geometry_a, material_a );
		mesh.position = new THREE.Vector3 (0,40,0);
		scene.add( mesh );
		
		var geometry_b	= new THREE.SphereGeometry( 10, 4, 4 );
		var material_b 	= new THREE.MeshNormalMaterial();
		meshsource = new THREE.Mesh( geometry_b, material_b );
		meshsource.position = new THREE.Vector3 (0,40,0);
		scene.add( meshsource );
		
		//init your audiolet shit
		audio = new Object();
		audio.freq = audio.gain = audio.pan = 1.0;
		initaudio = false;
		keyboardFuncs = new Object();
		keyboardFuncs.left = function(){ mesh.position.setX(mesh.position.x - 2); };
		keyboardFuncs.right = function(){ mesh.position.setX(mesh.position.x + 2); };
		keyboardFuncs.up = function(){ mesh.position.setZ(mesh.position.z - 2); };
		keyboardFuncs.down = function(){ mesh.position.setZ(mesh.position.z + 2); };
	function getInput() {
		if (keyboard.pressed("left")) { keyboardFuncs.left(); }
		if (keyboard.pressed("right")) { keyboardFuncs.right(); }
		if (keyboard.pressed("up")) { keyboardFuncs.up(); }
		if (keyboard.pressed("down")) { keyboardFuncs.down(); }
		if (keyboard.pressed("space"))
		{
			if (!initaudio) { playExample(); initaudio = true; }
		}
	}
	
	//function filterNegative(val) { return val > 0 ? val : 0; }
	
	
	function makeNoise() {
		/*var x, z, i, k;
		x = mesh.position.x;
		z = mesh.position.z;
		i = meshsource.position.x;
		k = meshsource.position.z;*/
		/*
		var distance = mesh.position.distanceTo(meshsource.position) / 100.0;
		audio.gain = filterNegative(0.9 - (Math.atan(distance) / (Math.PI / 2.0)));
		*/
		audio.gain = getGain(meshsource, mesh);
		audio.pan = getPan(meshsource, mesh, camera);
	}
	
//tree
var tree, treeContainer;
var branchTexture, branchMaterial;
//tree branch texture


				branchTexture = THREE.ImageUtils.loadTexture( "treebark.jpg" );
				branchTexture.minFilter = THREE.LinearFilter;
				branchTexture.magFilter = THREE.LinearFilter;
				branchTexture.wrapS = branchTexture.wrapT = THREE.RepeatWrapping;
				branchMaterial = new THREE.MeshLambertMaterial( { map:branchTexture, shininess: 2, ambient:0xffffff} );
				//branchMaterial = new THREE.MeshBasicMaterial( { color:0x0044ff, opacity:1, map: branchTexture } );
				branchMaterial.shading = THREE.SmoothShading;
				
				//create tree, will timeout some milliseconds
				
				tree = new Tree(branchMaterial, -1 , 25, 0, 1);
				tree.position = new THREE.Vector3(0,0,80)
				tree.rotation.x = -90 * Math.PI / 180;
				tree.scale = new THREE.Vector3(0.25,0.25,0.25)
				tree.castShadow = true;
				tree.receiveShadow = true;
				//tree container
				treeContainer = new THREE.Object3D();
				treeContainer.useQuaternion = true;
				treeContainer.add( tree );
				scene.add(treeContainer);
				
				function updateScaleRecursive( child  ) {
							for ( var c = 0; c < child.children.length; c++ ) {
								updateScaleRecursive( child.children[ c ] );
								child.children[ c ].scale = child.scale;	
							}
						}
			
	
var clock = new THREE.Clock();

	function animate() {
		var time = new Date().getTime();
		var delta = 0.001 * ( time - oldTime );
		oldTime = time;
		TWEEN.update();
		requestAnimationFrame( animate );
		controls.update(clock.getDelta());
		renderer.render( scene, camera );
			

		

// fireballshader turn 
	uniforms.time.value += 0.275 * delta;
			fireballmesh.rotation.y += 0.5 * delta;
			fireballmesh.rotation.x += 0.5 * delta;
	
	//fireball orbit
	
	var time = Date.now() / 6000;

	fireballmesh.position.x = 800 * Math.cos( time );
	fireballmesh.position.z = 800 * Math.sin( time );

	//particles
	
	for ( i = 0; i < scene.children.length; i ++ ) {

						var object = scene.children[ i ];

						if ( object instanceof THREE.ParticleSystem ) {

							object.rotation.y = (time * ( i < 4 ? i + 1 : - ( i + 1 ))/32 );

						}

					}

					for ( i = 0; i < materials.length; i ++ ) {

						color = parameters[i][0];

						h = ( 360 * ( color[0] + time ) % 360 ) / 360;
						materials[i].color.setHSV( h, color[1], color[2] );

					}
	
	//lights
	var time = Date.now() * 0.0025;
					var z = 20, d = 150;
	light1.position.x = Math.sin( time * 0.7 ) * d;
					light1.position.z = Math.cos( time * 0.3 ) * d;
					lightcube1.position = light1.position;

					light2.position.x = Math.cos( time * 0.3 ) * d;
					light2.position.z = Math.sin( time * 0.7 ) * d;
						lightcube2.position = light2.position;
					

					light3.position.x = Math.sin( time * 0.7 ) * d;
					light3.position.z = Math.sin( time * 0.5 ) * d;
						lightcube3.position = light3.position;
					

					light4.position.x = Math.sin( time * 0.3 ) * d;
					light4.position.z = Math.sin( time * 0.5 ) * d;
						lightcube4.position = light4.position;
						
						light5.position.x = Math.sin( time * 0.3 ) * d;
						light5.position.z = Math.sin( time * 0.5 ) * d;
							lightcube5.position = light5.position;
	
	//audio
	
		// get the input and update position
		getInput();
		
		//audioooooooooo
		makeNoise();
		
	}

	animate();
	</script>
	
	
	
</body>
</html>
