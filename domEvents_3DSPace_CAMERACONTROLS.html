<html>
<head>
	<script src="build/Three.js"></script>
	<script src="Tween.js"></script>
	<script src='threex.domevent.js'></script>
	<script src='threex.domevent.object3d.js'></script>
		<script src="jquery-1.7.2.js"></script>
	
</head>
<body>
	
	<script id="fragmentShader" type="x-shader/x-fragment">

		//
		// Description : Array and textureless GLSL 3D simplex noise function.
		//      Author : Ian McEwan, Ashima Arts.
		//  Maintainer : ijm
		//     Lastmod : 20110409 (stegu)
		//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.
		//               Distributed under the MIT License. See LICENSE file.
		//

		uniform float time;

		varying vec3 vTexCoord3D;
		varying vec3 vNormal;
		varying vec3 vViewPosition;

		vec4 permute( vec4 x ) {

			return mod( ( ( x * 34.0 ) + 1.0 ) * x, 289.0 );

		}

		vec4 taylorInvSqrt( vec4 r ) {

			return 1.79284291400159 - 0.85373472095314 * r;

		}

		float snoise( vec3 v ) {

			const vec2 C = vec2( 1.0 / 6.0, 1.0 / 3.0 );
			const vec4 D = vec4( 0.0, 0.5, 1.0, 2.0 );

			// First corner

			vec3 i  = floor( v + dot( v, C.yyy ) );
			vec3 x0 = v - i + dot( i, C.xxx );

			// Other corners

			vec3 g = step( x0.yzx, x0.xyz );
			vec3 l = 1.0 - g;
			vec3 i1 = min( g.xyz, l.zxy );
			vec3 i2 = max( g.xyz, l.zxy );

			//  x0 = x0 - 0. + 0.0 * C
			vec3 x1 = x0 - i1 + 1.0 * C.xxx;
			vec3 x2 = x0 - i2 + 2.0 * C.xxx;
			vec3 x3 = x0 - 1. + 3.0 * C.xxx;

			// Permutations

			i = mod( i, 289.0 );
			vec4 p = permute( permute( permute(
					 i.z + vec4( 0.0, i1.z, i2.z, 1.0 ) )
				   + i.y + vec4( 0.0, i1.y, i2.y, 1.0 ) )
				   + i.x + vec4( 0.0, i1.x, i2.x, 1.0 ) );

			// Gradients
			// ( N*N points uniformly over a square, mapped onto an octahedron.)

			float n_ = 1.0 / 7.0; // N=7

			vec3 ns = n_ * D.wyz - D.xzx;

			vec4 j = p - 49.0 * floor( p * ns.z *ns.z );  //  mod(p,N*N)

			vec4 x_ = floor( j * ns.z );
			vec4 y_ = floor( j - 7.0 * x_ );    // mod(j,N)

			vec4 x = x_ *ns.x + ns.yyyy;
			vec4 y = y_ *ns.x + ns.yyyy;
			vec4 h = 1.0 - abs( x ) - abs( y );

			vec4 b0 = vec4( x.xy, y.xy );
			vec4 b1 = vec4( x.zw, y.zw );

			vec4 s0 = floor( b0 ) * 2.0 + 1.0;
			vec4 s1 = floor( b1 ) * 2.0 + 1.0;
			vec4 sh = -step( h, vec4( 0.0 ) );

			vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;
			vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;

			vec3 p0 = vec3( a0.xy, h.x );
			vec3 p1 = vec3( a0.zw, h.y );
			vec3 p2 = vec3( a1.xy, h.z );
			vec3 p3 = vec3( a1.zw, h.w );

			// Normalise gradients

			vec4 norm = taylorInvSqrt( vec4( dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3) ) );
			p0 *= norm.x;
			p1 *= norm.y;
			p2 *= norm.z;
			p3 *= norm.w;

			// Mix final noise value

			vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3) ), 0.0 );
			m = m * m;
			return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),
										dot(p2,x2), dot(p3,x3) ) );

		}

		float heightMap( vec3 coord ) {

			float n = abs( snoise( coord ) );

			n += 0.25   * abs( snoise( coord * 2.0 ) );
			n += 0.25   * abs( snoise( coord * 4.0 ) );
			n += 0.125  * abs( snoise( coord * 8.0 ) );
			n += 0.0625 * abs( snoise( coord * 16.0 ) );

			return n;

		}

		void main( void ) {

			// height

			float n = heightMap( vTexCoord3D );

			// color

			gl_FragColor = vec4( vec3( 1.5 - n, 1.0 - n, 0.5 - n ), 1.0 );

			// normal

			const float e = 0.001;

			float nx = heightMap( vTexCoord3D + vec3( e, 0.0, 0.0 ) );
			float ny = heightMap( vTexCoord3D + vec3( 0.0, e, 0.0 ) );
			float nz = heightMap( vTexCoord3D + vec3( 0.0, 0.0, e ) );

			vec3 normal = normalize( vNormal + 0.05 * vec3( n - nx, n - ny, n - nz ) / e );

			// diffuse light

			vec3 vLightWeighting = vec3( 0.1 );

			vec4 lDirection = viewMatrix * vec4( normalize( vec3( 1.0, 0.0, 0.5 ) ), 0.0 );
			float directionalLightWeighting = dot( normal, normalize( lDirection.xyz ) ) * 0.25 + 0.75;
			vLightWeighting += vec3( 1.0 ) * directionalLightWeighting;

			// specular light

			vec3 dirHalfVector = normalize( lDirection.xyz + normalize( vViewPosition ) );

			float dirDotNormalHalf = dot( normal, dirHalfVector );

			float dirSpecularWeight = 0.0;
			if ( dirDotNormalHalf >= 0.0 )
				dirSpecularWeight = ( 1.0 - n ) * pow( dirDotNormalHalf, 5.0 );

			vLightWeighting += vec3( 1.0, 0.5, 0.0 ) * dirSpecularWeight * n * 2.0;

			gl_FragColor *= vec4( vLightWeighting, 1.0 );

		}

	</script>

	<script id="vertexShader" type="x-shader/x-vertex">

		uniform float time;
		uniform float scale;

		varying vec3 vTexCoord3D;
		varying vec3 vNormal;
		varying vec3 vViewPosition;

		void main( void ) {

			vec4 mPosition = objectMatrix * vec4( position, 1.0 );
			vNormal = normalize( normalMatrix * normal );
			vViewPosition = cameraPosition - mPosition.xyz;

			vTexCoord3D = scale * ( position.xyz + vec3( 0.0, 0.0, -time ) );
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}

	</script>
	
	<!-- ----- Moon Shader ----- -->

        <script id="vertex_shader2" type="x-shader/x-vertex">

                attribute vec4 tangent;

                varying vec3 vTangent;
		varying vec3 vBinormal;
		varying vec3 vNormal;
		varying vec2 vUv;

		varying vec3 vPointLightVector;
		varying vec3 vViewPosition;

                uniform vec3 uPointLightPos;

                #ifdef VERTEX_TEXTURES

                uniform sampler2D tDisp;
                uniform float uDisplacementScale;
		uniform float uDisplacementBias;

                #endif

		void main() {

                    vec4 mPosition = objectMatrix * vec4( position, 1.0 );
                    vViewPosition = cameraPosition - mPosition.xyz;

                    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
                    vNormal = normalize( normalMatrix * normal );

                    // tangent and binormal vectors

                    vTangent = normalize( normalMatrix * tangent.xyz );

                    vBinormal = cross( vNormal, vTangent ) * tangent.w;
                    vBinormal = normalize( vBinormal );

                    vUv = uv;

                    // point light

                    vec4 lPosition      = viewMatrix * vec4( uPointLightPos, 1.0 );
                    vPointLightVector   = normalize( lPosition.xyz - mvPosition.xyz );

                    #ifdef VERTEX_TEXTURES
                        vec3 dv                 = texture2D( tDisp, vUv ).xyz;
                        float df                = uDisplacementScale * dv.x + uDisplacementBias;
                        vec4 displacedPosition  = vec4( vNormal.xyz * df, 0.0 ) + mvPosition;
                        gl_Position             = projectionMatrix * displacedPosition;
                    #else
			gl_Position = projectionMatrix * mvPosition;
                    #endif
		}

        </script>

        <script id="fragment_shader2" type="x-shader/x-fragment">

            uniform vec3 uPointLightPos;

            uniform vec3 uAmbientLightColor;
            uniform vec3 uPointLightColor;

            uniform vec3 uAmbientColor;
            uniform vec3 uDiffuseColor;
            uniform vec3 uSpecularColor;
            uniform float uShininess;

            uniform sampler2D tDiffuse;
            uniform sampler2D tNormal;
            uniform sampler2D tSpec;
            uniform sampler2D tOcc;

            uniform float uNormalScale;

            varying vec3 vTangent;
            varying vec3 vBinormal;
            varying vec3 vNormal;
            varying vec2 vUv;

            varying vec3 vPointLightVector;
            varying vec3 vViewPosition;

            void main() {

                    vec3 diffuseTex     = texture2D( tDiffuse, vUv ).xyz;
                    vec3 specTex        = texture2D( tSpec, vUv ).xyz;
                    vec3 occTex         = texture2D( tOcc, vUv ).xyz;
                    vec3 normalTex      = texture2D( tNormal, vUv ).xyz * 2.0 - 1.0;

                    mat3 tsb            = mat3( vTangent, vBinormal, vNormal );
                    vec3 finalNormal    = tsb * normalTex.rgb;

                    vec3 normal         = normalize( finalNormal );
                    vec3 viewPosition   = normalize( vViewPosition );

                    // point light

                    vec4 pointDiffuse           = vec4( 0.0, 0.0, 0.0, 0.0 );
                    vec4 pointSpecular          = vec4( 0.0, 0.0, 0.0, 0.0 );

                    vec3 pointVector            = normalize( vPointLightVector );
                    vec3 pointHalfVector        = normalize( vPointLightVector - vViewPosition );

                    float pointDotNormalHalf    = dot( normal, pointHalfVector );
                    float pointDiffuseWeight    = max( dot( normal * 2.0, pointVector ), 0.0 );

                    float pointSpecularWeight   = 0.0;
                    if ( pointDotNormalHalf >= 0.0 )    pointSpecularWeight = pow( pointDotNormalHalf, 60.0 ) * pow(specTex.r, 4.0);

                    pointDiffuse               += vec4( uDiffuseColor, 1.0 ) * pointDiffuseWeight;
                    pointSpecular              += vec4( uSpecularColor, 1.0 ) * pointSpecularWeight;

                    // all lights contribution summation

                    float occlusion             = (1.0 - occTex.r) * .2; //pow(detailTex.g, 8.0);

                    vec4 totalLight             = vec4( uAmbientLightColor * uAmbientColor * occlusion, 1.0 );
                    totalLight                 += vec4( uPointLightColor, 1.0 ) * ( pointDiffuse + pointSpecular );

                    gl_FragColor = vec4( (diffuseTex * totalLight.xyz), 1.0 );

            }
        </script>
	
	<script>
	var container = document.createElement( 'div' ),
	width = 1630,
	height = 855,
	camera,
	scene,
	renderer,
	SHADOW_MAP_WIDTH = 2048,
	SHADOW_MAP_HEIGHT = 1024;

	container = document.body.appendChild( container );

	camera = new THREE.PerspectiveCamera( 50, width/height, 1, 5000 );
	// camera.position.set(158.16380101378365,38.91043790588581,-12.913103534540106);
	// camera.rotation.set(-1.191340631445364,1.252132902247305,1.4154706008869091);
	//camera.aspect = width / height;
	camera.updateProjectionMatrix();

	scene = new THREE.Scene();
scene.add(camera);
	renderer = new THREE.WebGLRenderer( { clearAlpha: 1, clearColor: 0x000000 } );
	renderer.setSize( width, height );
	renderer.shadowCameraNear = 3;
	renderer.shadowCameraFar = this.camera.far;
	renderer.shadowCameraFov = 50;
	renderer.shadowMapBias = 0.0039;
	renderer.shadowMapDarkness = 0.5;
	renderer.shadowMapWidth = SHADOW_MAP_WIDTH;
	renderer.shadowMapHeight = SHADOW_MAP_HEIGHT;
	renderer.shadowMapEnabled = true;
	renderer.shadowMapSoft = true;
	container.appendChild( renderer.domElement );
	
	
	//controls
	
	var controls = new THREE.FirstPersonControls(camera);
	controls.movementSpeed = 100;
	controls.lookSpeed = 0.15;

//lights

	var light1 = new THREE.PointLight();
	light1.intensity = 1;
	light1.castShadow = false;
	light1.color = new THREE.Color().setRGB(0,1,0.14901960784313725);
	light1.position.set(21.472392638036624,150,-2.3391812865496036);
	light1.rotation.set(0,0,0);
	light1.scale.set(1,1,1);
	scene.add( light1 );

	var light2 = new THREE.PointLight();
	light2.intensity = 1;
	light2.castShadow = false;
	light2.color = new THREE.Color().setRGB(0.0196078431372549,0.2980392156862745,1);
	light2.position.set(14.110429447852972,150,-257.30994152046776);
	light2.rotation.set(0,0,0);
	light2.scale.set(1,1,1);
	scene.add( light2 );

	var light3 = new THREE.PointLight();
	light3.intensity = 1;
	light3.castShadow = false;
	light3.color = new THREE.Color().setRGB(1,0.0196078431372549,0.14901960784313725);
	light3.position.set(14.110429447852544,150,152.04678362573108);
	light3.rotation.set(0,0,0);
	light3.scale.set(1,1,1);
	scene.add( light3 );

	var light4 = new THREE.PointLight();
	light4.intensity = 1;
	light4.castShadow = false;
	light4.color = new THREE.Color().setRGB(1,0,0.5);
	light4.position.set(-42.09591474245125,-244.17693169092934,-181.41097424412075);
	light4.rotation.set(0,0,0);
	light4.scale.set(1,1,1);
	scene.add( light4 );
	
	var light5 = new THREE.SpotLight();
	light5.intensity = 1;
	light5.castShadow = true;
	light5.color = new THREE.Color().setRGB(1,1,1);
	light5.position.set(-6.571936056838457,53.69540873460243,0);
	light5.rotation.set(0,0,0);
	light5.scale.set(1,1,1);
	scene.add( light5 );
	
	
	var lightcube1_geometry = new THREE.CubeGeometry(40,40,40);
	lightcube1_material =  new THREE.MeshBasicMaterial( { color: 0xff0000, wireframe: true } );
	lightcube1 = new THREE.Mesh( lightcube1_geometry, lightcube1_material );
	        scene.add( lightcube1 );
	
			var lightcube2_geometry = new THREE.CubeGeometry(40,40,40);
			lightcube2_material =  new THREE.MeshBasicMaterial( { color: 0x00ff00, wireframe: true } );
			lightcube2 = new THREE.Mesh( lightcube2_geometry, lightcube2_material );
			        scene.add( lightcube2 );
			
					var lightcube3_geometry = new THREE.CubeGeometry(40,40,40);
					lightcube3_material =  new THREE.MeshBasicMaterial( { color: 0x0000ff, wireframe: true } );
					lightcube3 = new THREE.Mesh( lightcube3_geometry, lightcube3_material );
					        scene.add( lightcube3 );
					
							var lightcube4_geometry = new THREE.CubeGeometry(40,40,40);
							lightcube4_material =  new THREE.MeshBasicMaterial( { color: 0xff00ff, wireframe: true } );
							lightcube4 = new THREE.Mesh( lightcube4_geometry, lightcube4_material );
							        scene.add( lightcube4 );
							
										var lightcube5_geometry = new THREE.CubeGeometry(40,40,40);
										lightcube5_material =  new THREE.MeshBasicMaterial( { color: 0x00ffff, wireframe: true } );
										lightcube5 = new THREE.Mesh( lightcube5_geometry, lightcube5_material );
										        scene.add( lightcube5 );
	//island 
		var island;
	var island_loader = new THREE.JSONLoader();
	island_loader.load( "island1.js", function(island_geometry) {
	var island_material = new THREE.MeshPhongMaterial();
	island_material.color = new THREE.Color().setRGB(1,1,1);
	island_material.ambient = new THREE.Color().setRGB(0.0196078431372549,0.0196078431372549,0.0196078431372549);
	island_material.specular = new THREE.Color().setRGB(0.06666666666666667,0.06666666666666667,0.06666666666666667);
    //island_material.map = THREE.ImageUtils.loadTexture("grass.jpg");


	island = new THREE.Mesh(island_geometry, island_material);
		island.receiveShadow = true;
	island.position.set(0,0,0);
	island.rotation.set(0,0,0);
	island.scale.set(100,100,100);
	scene.add( island );
	});

	

	var baptistery_loader = new THREE.JSONLoader();
	baptistery_loader.load( "last_baptistery2.js", function(bapstistery_geometry) {
	var baptistery_material = new THREE.MeshPhongMaterial();
	baptistery_material.color = new THREE.Color().setRGB(1,1,1);
	baptistery_material.ambient = new THREE.Color().setRGB(0.0196078431372549,0.0196078431372549,0.0196078431372549);
	baptistery_material.specular = new THREE.Color().setRGB(0.06666666666666667,0.06666666666666667,0.06666666666666667);
//material.map = THREE.ImageUtils.loadTexture("path/to/texture.jpg");
	
	

	var baptistery = new THREE.Mesh(bapstistery_geometry, baptistery_material);
	baptistery.position.set(2.4539877300613355,0,-11.695906432748425);
	baptistery.rotation.set(0,-0.84,0);
	baptistery.scale.set(2.5,2.5,2.5);
	scene.add( baptistery );
	});
var attachmentPointA, attachmentPointB, attachmentPointC, attachmentPointD, attachmentPointE, attachmentPointF;
		var attachmentPointA_loader = new THREE.JSONLoader();
		attachmentPointA_loader.load( "attachmentpoint2.js", function(attachmentPointA_geometry) {
		var attachmentpointA_material = new THREE.MeshPhongMaterial();
		attachmentpointA_material.color = new THREE.Color().setRGB(1,1,1);
		attachmentpointA_material.ambient = new THREE.Color().setRGB(0.0196078431372549,0.0196078431372549,0.0196078431372549);
		attachmentpointA_material.specular = new THREE.Color().setRGB(0.06666666666666667,0.06666666666666667,0.06666666666666667);
	//	material.map = THREE.ImageUtils.loadTexture("path/to/texture.jpg");



		attachmentPointA = new THREE.Mesh(attachmentPointA_geometry, attachmentpointA_material);
		attachmentPointA.position.set(-42.62877442273525,2.239641657334812,49.27211646136609);
		attachmentPointA.rotation.set(0,-0.84,0);
		attachmentPointA.scale.set(0.8,0.8,0.8);
		scene.add( attachmentPointA );
		});
		
			var attachmentPointB_loader = new THREE.JSONLoader();
			attachmentPointB_loader.load( "attachmentpoint2.js", function(attachmentPointB_geometry) {
			var attachmentpointB_material = new THREE.MeshPhongMaterial();
			attachmentpointB_material.color = new THREE.Color().setRGB(1,1,1);
			attachmentpointB_material.ambient = new THREE.Color().setRGB(0.0196078431372549,0.0196078431372549,0.0196078431372549);
			attachmentpointB_material.specular = new THREE.Color().setRGB(0.06666666666666667,0.06666666666666667,0.06666666666666667);
		//	material.map = THREE.ImageUtils.loadTexture("path/to/texture.jpg");
		
		attachmentPointB = new THREE.Mesh(attachmentPointB_geometry, attachmentpointB_material);
		attachmentPointB.position.set(-7.10479573712278,2.2396416573348112,98.5442329227322);
		attachmentPointB.rotation.set(0,-0.6283185307179586,-0.06981317007977328);
		attachmentPointB.scale.set(1,1,1);
		scene.add( attachmentPointB );
		});
		
		attachmentPointC_loader = new THREE.JSONLoader();
		attachmentPointC_loader.load( "attachmentpoint2.js", function(attachmentPointC_geometry) {
		var attachmentpointC_material = new THREE.MeshPhongMaterial();
		attachmentpointC_material.color = new THREE.Color().setRGB(1,1,1);
		attachmentpointC_material.ambient = new THREE.Color().setRGB(0.0196078431372549,0.0196078431372549,0.0196078431372549);
		attachmentpointC_material.specular = new THREE.Color().setRGB(0.06666666666666667,0.06666666666666667,0.06666666666666667);
	//	material.map = THREE.ImageUtils.loadTexture("path/to/texture.jpg");
	
	attachmentPointC = new THREE.Mesh(attachmentPointC_geometry, attachmentpointC_material);
	attachmentPointC.position.set(55.062166962699706,2.2396416573348112,-47.032474804031594);
	attachmentPointC.rotation.set(0,-0.6283185307179586,-0.06981317007977328);
	attachmentPointC.scale.set(1,1,1);
	scene.add( attachmentPointC );
	});
	
		var attachmentPointD_loader = new THREE.JSONLoader();
		attachmentPointD_loader.load( "attachmentpoint2.js", function(attachmentPointD_geometry) {
		var attachmentPointD_material = new THREE.MeshPhongMaterial();
		attachmentPointD_material.color = new THREE.Color().setRGB(1,1,1);
		attachmentPointD_material.ambient = new THREE.Color().setRGB(0.0196078431372549,0.0196078431372549,0.0196078431372549);
		attachmentPointD_material.specular = new THREE.Color().setRGB(0.06666666666666667,0.06666666666666667,0.06666666666666667);
	//	material.map = THREE.ImageUtils.loadTexture("path/to/texture.jpg");
	
	attachmentPointD = new THREE.Mesh(attachmentPointD_geometry, attachmentPointD_material);
	attachmentPointD.position.set(-51.50976909413862,2.239641657334812,-47.03247480403115);
	attachmentPointD.rotation.set(0,0.13962634015954656,0);
	attachmentPointD.scale.set(1,1,1);
	scene.add( attachmentPointD );
	});

		var attachmentPointE_loader = new THREE.JSONLoader();
		attachmentPointE_loader.load( "attachmentpoint2.js", function(attachmentPointE_geometry) {
		var attachmentPointE_material = new THREE.MeshPhongMaterial();
		attachmentPointE_material.color = new THREE.Color().setRGB(1,1,1);
		attachmentPointE_material.ambient = new THREE.Color().setRGB(0.0196078431372549,0.0196078431372549,0.0196078431372549);
		attachmentPointE_material.specular = new THREE.Color().setRGB(0.06666666666666667,0.06666666666666667,0.06666666666666667);
	//	material.map = THREE.ImageUtils.loadTexture("path/to/texture.jpg");
	
	attachmentPointE = new THREE.Mesh(attachmentPointE_geometry, attachmentPointE_material);
	attachmentPointE.position.set(39.07637655417396,2.239641657334812,47.032474804031395);
	attachmentPointE.rotation.set(0,0.13962634015954656,0);
	attachmentPointE.scale.set(1,1,1);
	scene.add( attachmentPointE );
	});
	
	var attachmentPointF_loader = new THREE.JSONLoader();
	attachmentPointF_loader.load( "attachmentpoint2.js", function(attachmentPointF_geometry) {
	var attachmentPointF_material = new THREE.MeshPhongMaterial();
	attachmentPointF_material.color = new THREE.Color().setRGB(1,1,1);
	attachmentPointF_material.ambient = new THREE.Color().setRGB(0.0196078431372549,0.0196078431372549,0.0196078431372549);
	attachmentPointF_material.specular = new THREE.Color().setRGB(0.06666666666666667,0.06666666666666667,0.06666666666666667);
//	material.map = THREE.ImageUtils.loadTexture("path/to/texture.jpg");

attachmentPointF = new THREE.Mesh(attachmentPointF_geometry, attachmentPointF_material);
attachmentPointF.position.set(-1.77619893428081,2.239641657334812,-100.7838745800672);
attachmentPointF.rotation.set(0,-2.303834612632515,0);
attachmentPointF.scale.set(1,1,1);
scene.add( attachmentPointF );
});

//plants
var plant1;
var loader = new THREE.JSONLoader();
loader.load( "plant1.js", function(plant1_geometry) {
var plant1_material = new THREE.MeshPhongMaterial();
plant1_material.color = new THREE.Color().setRGB(1,1,1);
plant1_material.ambient = new THREE.Color().setRGB(0.0196078431372549,0.0196078431372549,0.0196078431372549);
plant1_material.specular = new THREE.Color().setRGB(0.06666666666666667,0.06666666666666667,0.06666666666666667);
//material.map = THREE.ImageUtils.loadTexture("path/to/texture.jpg");
plant1 = new THREE.Mesh(plant1_geometry, plant1_material);
plant1.position.set(30,10,10);
plant1.rotation.set(0,0,0);
plant1.scale.set(10,10,10);
plant1.castShadow = true;
scene.add( plant1 );
});



//fireballsun

var start_time, uniforms, fireballmesh;
var oldTime = new Date().getTime();

	start_time = new Date().getTime();

	uniforms = {
		time: 	{ type: "f", value: 1.0 },
		scale: 	{ type: "f", value: 1.5 }
	};
		var size = 0.75;
		
			var fireballmaterial = new THREE.ShaderMaterial( {

				uniforms: uniforms,
				vertexShader: document.getElementById( 'vertexShader' ).textContent,
				fragmentShader: document.getElementById( 'fragmentShader' ).textContent

			} );
			
			fireballmesh = new THREE.Mesh( new THREE.SphereGeometry( size, 64, 32 ), fireballmaterial );
			scene.add( fireballmesh );
fireballmesh.position.set(1000,300,100);
fireballmesh.scale = new THREE.Vector3(150,150,150);


var domEvent;
var mouse = { x: 0, y: 0 };

THREE.Object3D._threexDomEvent.camera(camera);
	
	new THREE.JSONLoader().load('teapot.js', function(geometry){
		var meshes	= buildMeshes(geometry);
		bindEvents(meshes);
	});



function buildMeshes(geometry){
	var meshes	= {};
	var dx		= 14;
	var dy		= 12;
	var material	= new THREE.MeshLambertMaterial( { color: 0xFF8800 } );
	var mesh	= new THREE.Mesh( geometry, material );
	mesh.position.set(0,dy,0);
	mesh.rotation.x	= +1*Math.PI/2;
	mesh.rotation.y	= -1*Math.PI/2;
	mesh.scale= new THREE.Vector3(10,10,10)
	scene.add( mesh );
	meshes['sphere1']	= mesh;

	var material	= new THREE.MeshLambertMaterial( { color: 0x88CC44 } );
	var mesh	= new THREE.Mesh( geometry, material );
	mesh.position.set(-dx*5,-dy,0);
	scene.add( mesh );
	meshes['sphere2']	= mesh;

	var material	= new THREE.MeshLambertMaterial( { color: 0x88CC44 } );
	var mesh	= new THREE.Mesh( geometry, material );
	mesh.position.set(dx*5,-dy,0);
	mesh.rotation.y	= Math.PI;
	scene.add( mesh );
	meshes['sphere3']	= mesh;

	return meshes;	
}


function bindEvents(meshes){
	meshes['sphere2'].on('click', function(event){
		var object3d	= event.target;
		var scale	= 20;
		new TWEEN.Tween(object3d.scale)
			.to({x: scale, y: scale, z: scale}, 100)
			.easing(TWEEN.Easing.Quartic.EaseIn)
			.start();
		new TWEEN.Tween(object3d.material.color)
			.to({r: 1, g: 0.5, b: 0}, 100)
			.easing(TWEEN.Easing.Quartic.EaseIn)
			.start();
	}).on('mouseup', function(event){
		var object3d	= event.target;
		var scale	= 10;
		new TWEEN.Tween(object3d.scale)
			.to({x: scale, y: scale, z: scale}, 300)
			.easing(TWEEN.Easing.Quartic.EaseIn)
			.start();
		new TWEEN.Tween(object3d.material.color)
			.to({r: 0.5, g: 0.75, b: 0.25}, 300)
			.easing(TWEEN.Easing.Quartic.EaseIn)
			.start();
	});
	meshes['sphere1'].on('mouseover', function(event){
		var object3d	= event.target;
		if( object3d.rotation.x < Math.PI/4 ){
			var rotation	= {x: Math.PI/2};
			var color	= {r: 1, g: 0.5, b: 0};
		}else{
			var rotation	= {x:0};
			var color	= {r: 0.5, g: 0.75, b: 0.25};
		}
		new TWEEN.Tween(object3d.rotation).to(rotation, 800)
			.easing(TWEEN.Easing.Bounce.EaseOut).start();
		new TWEEN.Tween(object3d.material.color).to(color, 300)
			.easing(TWEEN.Easing.Quartic.EaseIn).start();
	});	

	meshes['sphere3'].on('mouseover', function(event){
		var object3d	= event.target;
		new TWEEN.Tween(object3d.scale)
			.to({x: 1.5, y: 1.5, z: 1.5}, 200)
			.easing(TWEEN.Easing.Quartic.EaseIn)
			.start();
		new TWEEN.Tween(object3d.material.color)
			.to({r: 1, g: 0.5, b: 0}, 600)
			.delay(400)
			.easing(TWEEN.Easing.Quartic.EaseIn)
			.start();
		new TWEEN.Tween(object3d.rotation)
			.to({y: 3*Math.PI}, 1000)
			.easing(TWEEN.Easing.Quartic.EaseIn)
			.start();
	}).on('mouseout', function(event){
		var object3d	= event.target;
		new TWEEN.Tween(object3d.scale)
			.to({x: 1, y: 1, z: 1}, 300)
			.easing(TWEEN.Easing.Quartic.EaseOut)
			.start();
		new TWEEN.Tween(object3d.material.color)
			.to({r: 0.5, g: 0.75, b: 0.25}, 600)
			.delay(400)
			.easing(TWEEN.Easing.Quartic.EaseOut)
			.start();
		new TWEEN.Tween(object3d.rotation)
			.to({y: Math.PI}, 1000)
			.easing(TWEEN.Easing.Quartic.EaseOut)
			.start();
	});
	
}

// particles

var particles, geometry, materials = [], parameters, i, h, color;
geometry = new THREE.Geometry();

				for ( i = 0; i < 2000; i ++ ) {

					vector = new THREE.Vector3( Math.random() * 2000 - 1000, Math.random() * 2000 - 1000, Math.random() * 2000 - 1000 );
					geometry.vertices.push( new THREE.Vertex( vector ) );

				}

				//parameters = [ [ [1.0, 1.0, 1.0], 5 ], [ [0.95, 1, 1], 4 ], [ [0.90, 1, 1], 3 ], [ [0.85, 1, 1], 2 ], [ [0.80, 1, 1], 1 ] ];
				parameters = [ [ 0xff0000, 5 ], [ 0xff3300, 4 ], [ 0xff6600, 3 ], [ 0xff9900, 2 ], [ 0xffaa00, 1 ] ];
				//parameters = [ [ 0xffffff, 5 ], [ 0xdddddd, 4 ], [ 0xaaaaaa, 3 ], [ 0x999999, 2 ], [ 0x777777, 1 ] ];

				for ( i = 0; i < parameters.length; i ++ ) {

					size  = parameters[i][1];
					color = parameters[i][0];

					//materials[i] = new THREE.ParticleBasicMaterial( { color: color, size: size } );

					materials[i] = new THREE.ParticleBasicMaterial( { size: size } );
					materials[i].color.setHSV( color[0], color[1], color[2] );

					particles = new THREE.ParticleSystem( geometry, materials[i] );

					particles.rotation.x = Math.random() * 6;
					particles.rotation.y = Math.random() * 6;
					particles.rotation.z = Math.random() * 6;

					scene.add( particles );

				}
				
// moon

// --- Moon

var geometry = new Sphere( 400, 60, 60 );
geometry.computeTangents();

                                var ambient = 0x090909, diffuse = 0xaaaaaa, specular = 0xffffff, shininess = 4.0, scale = 23;
								var sphere          = new Sphere( 100, 8, 8 );
								                                light               = new THREE.Mesh( sphere, new THREE.MeshBasicMaterial( { color:0xff66aa } ) );
								                                light.position      = pointLight.position;
								                                light.scale.x       = light.scale.y = light.scale.z = 0.05;
								                                scene.addObject(light);
                                var uniforms = {

                                    tNormal:    { type: "t", value: 2, texture: THREE.ImageUtils.loadTexture( 'moon_NRM.png') },
                                    tDiffuse:   { type: "t", value: 0, texture:  THREE.ImageUtils.loadTexture( 'moon_COLOR.png' ) },
                                    tSpec:      { type: "t", value: 3, texture:  THREE.ImageUtils.loadTexture( 'moon_SPEC.png' ) },
                                    tOcc:       { type: "t", value: 3, texture:  THREE.ImageUtils.loadTexture( 'moon_OCC.png' ) },
                                    tDisp:      {type:"t", value: 1, texture:  THREE.ImageUtils.loadTexture( 'moon_DISP.png' ) },

                                    uDisplacementBias:  { type:"f", value: -0.428408 * scale},
                                    uDisplacementScale: { type:"f", value: 2.436143 * scale},

                                    uPointLightPos:     { type: "v3", value: pointLight.position },
                                    uPointLightColor:   { type: "c", value: pointLight.color },

                                    uAmbientLightColor: { type: "c", value: ambientLight.color},

                                    uDiffuseColor:      { type:"c", value: new THREE.Color( diffuse ) },
                                    uSpecularColor:     { type:"c", value: new THREE.Color( specular )},
                                    uAmbientColor:      { type:"c", value: new THREE.Color( ambient )},

                                    uShininess:         { type:"f", value: shininess}
                                };

                                var material = new THREE.ShaderMaterial( {
                                        uniforms: uniforms,
                                        vertex_shader: document.getElementById( 'vertex_shader2' ).textContent,
                                        fragment_shader: document.getElementById( 'fragment_shader2' ).textContent
                                } );


                                var geometry = new Sphere( 400, 60, 60 );
                                geometry.computeTangents();

                                moon = new THREE.Mesh( geometry, material );
                                moon.position.z = -600;
                                scene.addObject( moon );


var clock = new THREE.Clock();

	function animate() {
		var time = new Date().getTime();
		var delta = 0.001 * ( time - oldTime );
		oldTime = time;
		TWEEN.update();
		requestAnimationFrame( animate );
		controls.update(clock.getDelta());
		renderer.render( scene, camera );
			

		

// fireballshader turn 
	uniforms.time.value += 0.275 * delta;
			fireballmesh.rotation.y += 0.5 * delta;
			fireballmesh.rotation.x += 0.5 * delta;
	
	//fireball orbit
	
	var time = Date.now() / 6000;

	fireballmesh.position.x = 800 * Math.cos( time );
	fireballmesh.position.z = 800 * Math.sin( time );

	//particles
	
	for ( i = 0; i < scene.children.length; i ++ ) {

						var object = scene.children[ i ];

						if ( object instanceof THREE.ParticleSystem ) {

							object.rotation.y = (time * ( i < 4 ? i + 1 : - ( i + 1 ))/32 );

						}

					}

					for ( i = 0; i < materials.length; i ++ ) {

						color = parameters[i][0];

						h = ( 360 * ( color[0] + time ) % 360 ) / 360;
						materials[i].color.setHSV( h, color[1], color[2] );

					}
	
	//lights
	var time = Date.now() * 0.0025;
					var z = 20, d = 150;
	light1.position.x = Math.sin( time * 0.7 ) * d;
					light1.position.z = Math.cos( time * 0.3 ) * d;
					lightcube1.position.x = light1.position.x;
					lightcube1.position.y = light1.position.y;
					lightcube1.position.z = light1.position.z;

					light2.position.x = Math.cos( time * 0.3 ) * d;
					light2.position.z = Math.sin( time * 0.7 ) * d;
						lightcube2.position.x = light2.position.x;
						lightcube2.position.y = light2.position.y;
						lightcube2.position.z = light2.position.z;
					

					light3.position.x = Math.sin( time * 0.7 ) * d;
					light3.position.z = Math.sin( time * 0.5 ) * d;
						lightcube3.position.x = light3.position.x;
						lightcube3.position.y = light3.position.y;
						lightcube3.position.z = light3.position.z;
					

					light4.position.x = Math.sin( time * 0.3 ) * d;
					light4.position.z = Math.sin( time * 0.5 ) * d;
						lightcube4.position.x = light4.position.x;
						lightcube4.position.y = light4.position.y;
						lightcube4.position.z = light4.position.z;
						
						light5.position.x = Math.sin( time * 0.3 ) * d;
						light5.position.z = Math.sin( time * 0.5 ) * d;
							lightcube5.position.x = light5.position.x;
							lightcube5.position.y = light5.position.y;
							lightcube5.position.z = light5.position.z;
	
	}

	animate();
	</script>
</body>
</html>
