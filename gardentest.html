<html>
<head>
	<script src="build/Three.js"></script>
	<script src="Tween.js"></script>
	<script src='threex.domevent.js'></script>
	<script src='threex.domevent.object3d.js'></script>
	
</head>
<body>
	
	<script id="fragmentShader" type="x-shader/x-fragment">

		//
		// Description : Array and textureless GLSL 3D simplex noise function.
		//      Author : Ian McEwan, Ashima Arts.
		//  Maintainer : ijm
		//     Lastmod : 20110409 (stegu)
		//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.
		//               Distributed under the MIT License. See LICENSE file.
		//

		uniform float time;

		varying vec3 vTexCoord3D;
		varying vec3 vNormal;
		varying vec3 vViewPosition;

		vec4 permute( vec4 x ) {

			return mod( ( ( x * 34.0 ) + 1.0 ) * x, 289.0 );

		}

		vec4 taylorInvSqrt( vec4 r ) {

			return 1.79284291400159 - 0.85373472095314 * r;

		}

		float snoise( vec3 v ) {

			const vec2 C = vec2( 1.0 / 6.0, 1.0 / 3.0 );
			const vec4 D = vec4( 0.0, 0.5, 1.0, 2.0 );

			// First corner

			vec3 i  = floor( v + dot( v, C.yyy ) );
			vec3 x0 = v - i + dot( i, C.xxx );

			// Other corners

			vec3 g = step( x0.yzx, x0.xyz );
			vec3 l = 1.0 - g;
			vec3 i1 = min( g.xyz, l.zxy );
			vec3 i2 = max( g.xyz, l.zxy );

			//  x0 = x0 - 0. + 0.0 * C
			vec3 x1 = x0 - i1 + 1.0 * C.xxx;
			vec3 x2 = x0 - i2 + 2.0 * C.xxx;
			vec3 x3 = x0 - 1. + 3.0 * C.xxx;

			// Permutations

			i = mod( i, 289.0 );
			vec4 p = permute( permute( permute(
					 i.z + vec4( 0.0, i1.z, i2.z, 1.0 ) )
				   + i.y + vec4( 0.0, i1.y, i2.y, 1.0 ) )
				   + i.x + vec4( 0.0, i1.x, i2.x, 1.0 ) );

			// Gradients
			// ( N*N points uniformly over a square, mapped onto an octahedron.)

			float n_ = 1.0 / 7.0; // N=7

			vec3 ns = n_ * D.wyz - D.xzx;

			vec4 j = p - 49.0 * floor( p * ns.z *ns.z );  //  mod(p,N*N)

			vec4 x_ = floor( j * ns.z );
			vec4 y_ = floor( j - 7.0 * x_ );    // mod(j,N)

			vec4 x = x_ *ns.x + ns.yyyy;
			vec4 y = y_ *ns.x + ns.yyyy;
			vec4 h = 1.0 - abs( x ) - abs( y );

			vec4 b0 = vec4( x.xy, y.xy );
			vec4 b1 = vec4( x.zw, y.zw );

			vec4 s0 = floor( b0 ) * 2.0 + 1.0;
			vec4 s1 = floor( b1 ) * 2.0 + 1.0;
			vec4 sh = -step( h, vec4( 0.0 ) );

			vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;
			vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;

			vec3 p0 = vec3( a0.xy, h.x );
			vec3 p1 = vec3( a0.zw, h.y );
			vec3 p2 = vec3( a1.xy, h.z );
			vec3 p3 = vec3( a1.zw, h.w );

			// Normalise gradients

			vec4 norm = taylorInvSqrt( vec4( dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3) ) );
			p0 *= norm.x;
			p1 *= norm.y;
			p2 *= norm.z;
			p3 *= norm.w;

			// Mix final noise value

			vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3) ), 0.0 );
			m = m * m;
			return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),
										dot(p2,x2), dot(p3,x3) ) );

		}

		float heightMap( vec3 coord ) {

			float n = abs( snoise( coord ) );

			n += 0.25   * abs( snoise( coord * 2.0 ) );
			n += 0.25   * abs( snoise( coord * 4.0 ) );
			n += 0.125  * abs( snoise( coord * 8.0 ) );
			n += 0.0625 * abs( snoise( coord * 16.0 ) );

			return n;

		}

		void main( void ) {

			// height

			float n = heightMap( vTexCoord3D );

			// color

			gl_FragColor = vec4( vec3( 1.5 - n, 1.0 - n, 0.5 - n ), 1.0 );

			// normal

			const float e = 0.001;

			float nx = heightMap( vTexCoord3D + vec3( e, 0.0, 0.0 ) );
			float ny = heightMap( vTexCoord3D + vec3( 0.0, e, 0.0 ) );
			float nz = heightMap( vTexCoord3D + vec3( 0.0, 0.0, e ) );

			vec3 normal = normalize( vNormal + 0.05 * vec3( n - nx, n - ny, n - nz ) / e );

			// diffuse light

			vec3 vLightWeighting = vec3( 0.1 );

			vec4 lDirection = viewMatrix * vec4( normalize( vec3( 1.0, 0.0, 0.5 ) ), 0.0 );
			float directionalLightWeighting = dot( normal, normalize( lDirection.xyz ) ) * 0.25 + 0.75;
			vLightWeighting += vec3( 1.0 ) * directionalLightWeighting;

			// specular light

			vec3 dirHalfVector = normalize( lDirection.xyz + normalize( vViewPosition ) );

			float dirDotNormalHalf = dot( normal, dirHalfVector );

			float dirSpecularWeight = 0.0;
			if ( dirDotNormalHalf >= 0.0 )
				dirSpecularWeight = ( 1.0 - n ) * pow( dirDotNormalHalf, 5.0 );

			vLightWeighting += vec3( 1.0, 0.5, 0.0 ) * dirSpecularWeight * n * 2.0;

			gl_FragColor *= vec4( vLightWeighting, 1.0 );

		}

	</script>

	<script id="vertexShader" type="x-shader/x-vertex">

		uniform float time;
		uniform float scale;

		varying vec3 vTexCoord3D;
		varying vec3 vNormal;
		varying vec3 vViewPosition;

		void main( void ) {

			vec4 mPosition = objectMatrix * vec4( position, 1.0 );
			vNormal = normalize( normalMatrix * normal );
			vViewPosition = cameraPosition - mPosition.xyz;

			vTexCoord3D = scale * ( position.xyz + vec3( 0.0, 0.0, -time ) );
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}

	</script>
	
	
	<script>
	var container = document.createElement( 'div' ),
	width = 1630,
	height = 855,
	camera,
	scene,
	renderer,
	SHADOW_MAP_WIDTH = 2048,
	SHADOW_MAP_HEIGHT = 1024;

	container = document.body.appendChild( container );

	camera = new THREE.PerspectiveCamera( 50, 1, 1, 5000 );
	camera.position.set(158.16380101378365,38.91043790588581,-12.913103534540106);
	camera.rotation.set(-1.191340631445364,1.252132902247305,1.4154706008869091);
	camera.aspect = width / height;
	camera.updateProjectionMatrix();

	scene = new THREE.Scene();
scene.add(camera);
	renderer = new THREE.WebGLRenderer( { clearAlpha: 1, clearColor: 0x000000 } );
	renderer.setSize( width, height );
	renderer.shadowCameraNear = 3;
	renderer.shadowCameraFar = this.camera.far;
	renderer.shadowCameraFov = 50;
	renderer.shadowMapBias = 0.0039;
	renderer.shadowMapDarkness = 0.5;
	renderer.shadowMapWidth = SHADOW_MAP_WIDTH;
	renderer.shadowMapHeight = SHADOW_MAP_HEIGHT;
	renderer.shadowMapEnabled = true;
	renderer.shadowMapSoft = true;
	container.appendChild( renderer.domElement );


	var mesh = new THREE.PointLight();
	mesh.intensity = 1;
	mesh.castShadow = false;
	mesh.color = new THREE.Color().setRGB(0,1,0.14901960784313725);
	mesh.position.set(21.472392638036624,150,-2.3391812865496036);
	mesh.rotation.set(0,0,0);
	mesh.scale.set(1,1,1);
	scene.add( mesh );

	var mesh = new THREE.PointLight();
	mesh.intensity = 1;
	mesh.castShadow = false;
	mesh.color = new THREE.Color().setRGB(0.0196078431372549,0.2980392156862745,1);
	mesh.position.set(14.110429447852972,150,-257.30994152046776);
	mesh.rotation.set(0,0,0);
	mesh.scale.set(1,1,1);
	scene.add( mesh );

	var mesh = new THREE.PointLight();
	mesh.intensity = 1;
	mesh.castShadow = false;
	mesh.color = new THREE.Color().setRGB(1,0.0196078431372549,0.14901960784313725);
	mesh.position.set(14.110429447852544,150,152.04678362573108);
	mesh.rotation.set(0,0,0);
	mesh.scale.set(1,1,1);
	scene.add( mesh );

	var island_loader = new THREE.JSONLoader();
	island_loader.load( "island1.js", function(island_geometry) {
	var island_material = new THREE.MeshPhongMaterial();
	island_material.color = new THREE.Color().setRGB(1,1,1);
	island_material.ambient = new THREE.Color().setRGB(0.0196078431372549,0.0196078431372549,0.0196078431372549);
	island_material.specular = new THREE.Color().setRGB(0.06666666666666667,0.06666666666666667,0.06666666666666667);
	//material.map = THREE.ImageUtils.loadTexture("path/to/texture.jpg");

	var island = new THREE.Mesh(island_geometry, island_material);
	island.position.set(0,0,0);
	island.rotation.set(0,0,0);
	island.scale.set(100,100,100);
	scene.add( island );
	});
	

	var baptistery_loader = new THREE.JSONLoader();
	baptistery_loader.load( "last_baptistery2.js", function(bapstistery_geometry) {
	var baptistery_material = new THREE.MeshPhongMaterial();
	baptistery_material.color = new THREE.Color().setRGB(1,1,1);
	baptistery_material.ambient = new THREE.Color().setRGB(0.0196078431372549,0.0196078431372549,0.0196078431372549);
	baptistery_material.specular = new THREE.Color().setRGB(0.06666666666666667,0.06666666666666667,0.06666666666666667);
//	material.map = THREE.ImageUtils.loadTexture("path/to/texture.jpg");
	
	

	var baptistery = new THREE.Mesh(bapstistery_geometry, baptistery_material);
	baptistery.position.set(2.4539877300613355,0,-11.695906432748425);
	baptistery.rotation.set(0,-0.84,0);
	baptistery.scale.set(2.5,2.5,2.5);
	scene.add( baptistery );
	});

		var attachmentPointA_loader = new THREE.JSONLoader();
		attachmentPointA_loader.load( "attachmentpoint2.js", function(attachmentPointA_geometry) {
		var attachmentpointA_material = new THREE.MeshPhongMaterial();
		attachmentpointA_material.color = new THREE.Color().setRGB(1,1,1);
		attachmentpointA_material.ambient = new THREE.Color().setRGB(0.0196078431372549,0.0196078431372549,0.0196078431372549);
		attachmentpointA_material.specular = new THREE.Color().setRGB(0.06666666666666667,0.06666666666666667,0.06666666666666667);
	//	material.map = THREE.ImageUtils.loadTexture("path/to/texture.jpg");



		var attachmentPointA = new THREE.Mesh(attachmentPointA_geometry, attachmentpointA_material);
		attachmentPointA.position.set(-42.62877442273525,2.239641657334812,49.27211646136609);
		attachmentPointA.rotation.set(0,-0.84,0);
		attachmentPointA.scale.set(0.8,0.8,0.8);
		scene.add( attachmentPointA );
		});
		
			var attachmentPointB_loader = new THREE.JSONLoader();
			attachmentPointB_loader.load( "attachmentpoint2.js", function(attachmentPointB_geometry) {
			var attachmentpointB_material = new THREE.MeshPhongMaterial();
			attachmentpointB_material.color = new THREE.Color().setRGB(1,1,1);
			attachmentpointB_material.ambient = new THREE.Color().setRGB(0.0196078431372549,0.0196078431372549,0.0196078431372549);
			attachmentpointB_material.specular = new THREE.Color().setRGB(0.06666666666666667,0.06666666666666667,0.06666666666666667);
		//	material.map = THREE.ImageUtils.loadTexture("path/to/texture.jpg");
		
		var attachmentPointB = new THREE.Mesh(attachmentPointB_geometry, attachmentpointB_material);
		attachmentPointB.position.set(-7.10479573712278,2.2396416573348112,98.5442329227322);
		attachmentPointB.rotation.set(0,-0.6283185307179586,-0.06981317007977328);
		attachmentPointB.scale.set(1,1,1);
		scene.add( attachmentPointB );
		});
		
		var attachmentPointC_loader = new THREE.JSONLoader();
		attachmentPointC_loader.load( "attachmentpoint2.js", function(attachmentPointC_geometry) {
		var attachmentpointC_material = new THREE.MeshPhongMaterial();
		attachmentpointC_material.color = new THREE.Color().setRGB(1,1,1);
		attachmentpointC_material.ambient = new THREE.Color().setRGB(0.0196078431372549,0.0196078431372549,0.0196078431372549);
		attachmentpointC_material.specular = new THREE.Color().setRGB(0.06666666666666667,0.06666666666666667,0.06666666666666667);
	//	material.map = THREE.ImageUtils.loadTexture("path/to/texture.jpg");
	
	var attachmentPointC = new THREE.Mesh(attachmentPointC_geometry, attachmentpointC_material);
	attachmentPointC.position.set(55.062166962699706,2.2396416573348112,-47.032474804031594);
	attachmentPointC.rotation.set(0,-0.6283185307179586,-0.06981317007977328);
	attachmentPointC.scale.set(1,1,1);
	scene.add( attachmentPointC );
	});
	
		var attachmentPointD_loader = new THREE.JSONLoader();
		attachmentPointD_loader.load( "attachmentpoint2.js", function(attachmentPointD_geometry) {
		var attachmentPointD_material = new THREE.MeshPhongMaterial();
		attachmentPointD_material.color = new THREE.Color().setRGB(1,1,1);
		attachmentPointD_material.ambient = new THREE.Color().setRGB(0.0196078431372549,0.0196078431372549,0.0196078431372549);
		attachmentPointD_material.specular = new THREE.Color().setRGB(0.06666666666666667,0.06666666666666667,0.06666666666666667);
	//	material.map = THREE.ImageUtils.loadTexture("path/to/texture.jpg");
	
	var attachmentPointD = new THREE.Mesh(attachmentPointD_geometry, attachmentPointD_material);
	attachmentPointD.position.set(-51.50976909413862,2.239641657334812,-47.03247480403115);
	attachmentPointD.rotation.set(0,0.13962634015954656,0);
	attachmentPointD.scale.set(1,1,1);
	scene.add( attachmentPointD );
	});

		var attachmentPointE_loader = new THREE.JSONLoader();
		attachmentPointE_loader.load( "attachmentpoint2.js", function(attachmentPointE_geometry) {
		var attachmentPointE_material = new THREE.MeshPhongMaterial();
		attachmentPointE_material.color = new THREE.Color().setRGB(1,1,1);
		attachmentPointE_material.ambient = new THREE.Color().setRGB(0.0196078431372549,0.0196078431372549,0.0196078431372549);
		attachmentPointE_material.specular = new THREE.Color().setRGB(0.06666666666666667,0.06666666666666667,0.06666666666666667);
	//	material.map = THREE.ImageUtils.loadTexture("path/to/texture.jpg");
	
	var attachmentPointE = new THREE.Mesh(attachmentPointE_geometry, attachmentPointE_material);
	attachmentPointE.position.set(39.07637655417396,2.239641657334812,47.032474804031395);
	attachmentPointE.rotation.set(0,0.13962634015954656,0);
	attachmentPointE.scale.set(1,1,1);
	scene.add( attachmentPointE );
	});
	
	var attachmentPointF_loader = new THREE.JSONLoader();
	attachmentPointF_loader.load( "attachmentpoint2.js", function(attachmentPointF_geometry) {
	var attachmentPointF_material = new THREE.MeshPhongMaterial();
	attachmentPointF_material.color = new THREE.Color().setRGB(1,1,1);
	attachmentPointF_material.ambient = new THREE.Color().setRGB(0.0196078431372549,0.0196078431372549,0.0196078431372549);
	attachmentPointF_material.specular = new THREE.Color().setRGB(0.06666666666666667,0.06666666666666667,0.06666666666666667);
//	material.map = THREE.ImageUtils.loadTexture("path/to/texture.jpg");

var attachmentPointF = new THREE.Mesh(attachmentPointF_geometry, attachmentPointF_material);
attachmentPointF.position.set(-1.77619893428081,2.239641657334812,-100.7838745800672);
attachmentPointF.rotation.set(0,-2.303834612632515,0);
attachmentPointF.scale.set(1,1,1);
scene.add( attachmentPointF );
});

var start_time, uniforms, fireballmesh;
var oldTime = new Date().getTime();

	start_time = new Date().getTime();

	uniforms = {
		time: 	{ type: "f", value: 1.0 },
		scale: 	{ type: "f", value: 1.5 }
	};
		var size = 0.75;
		
			var fireballmaterial = new THREE.ShaderMaterial( {

				uniforms: uniforms,
				vertexShader: document.getElementById( 'vertexShader' ).textContent,
				fragmentShader: document.getElementById( 'fragmentShader' ).textContent

			} );
			
			fireballmesh = new THREE.Mesh( new THREE.SphereGeometry( size, 64, 32 ), fireballmaterial );
			scene.add( fireballmesh );
fireballmesh.position.set(10,30,0);
fireballmesh.scale = new THREE.Vector3(3,3,3);


var domEvent;
var mouse = { x: 0, y: 0 };

THREE.Object3D._threexDomEvent.camera(camera);
	
	new THREE.JSONLoader().load('teapot.js', function(geometry){
		var meshes	= buildMeshes(geometry);
		bindEvents(meshes);
	});



function buildMeshes(geometry){
	var meshes	= {};
	var dx		= 14;
	var dy		= 12;
	var material	= new THREE.MeshLambertMaterial( { color: 0xFF8800 } );
	var mesh	= new THREE.Mesh( geometry, material );
	mesh.position.set(0,dy,0);
	mesh.rotation.x	= +1*Math.PI/2;
	mesh.rotation.y	= -1*Math.PI/2;
	mesh.scale= new THREE.Vector3(10,10,10)
	scene.add( mesh );
	meshes['sphere1']	= mesh;

	var material	= new THREE.MeshLambertMaterial( { color: 0x88CC44 } );
	var mesh	= new THREE.Mesh( geometry, material );
	mesh.position.set(-dx,-dy,0);
	scene.add( mesh );
	meshes['sphere2']	= mesh;

	var material	= new THREE.MeshLambertMaterial( { color: 0x88CC44 } );
	var mesh	= new THREE.Mesh( geometry, material );
	mesh.position.set(dx,-dy,0);
	mesh.rotation.y	= Math.PI;
	scene.add( mesh );
	meshes['sphere3']	= mesh;

	return meshes;	
}


function bindEvents(meshes){
	meshes['sphere2'].on('mouseover', function(event){
		var object3d	= event.target;
		var scale	= 10.4;
		new TWEEN.Tween(object3d.scale)
			.to({x: scale, y: scale, z: scale}, 100)
			.easing(TWEEN.Easing.Quartic.EaseIn)
			.start();
		new TWEEN.Tween(object3d.material.color)
			.to({r: 1, g: 0.5, b: 0}, 100)
			.easing(TWEEN.Easing.Quartic.EaseIn)
			.start();
	}).on('mouseup', function(event){
		var object3d	= event.target;
		var scale	= 10;
		new TWEEN.Tween(object3d.scale)
			.to({x: scale, y: scale, z: scale}, 300)
			.easing(TWEEN.Easing.Quartic.EaseIn)
			.start();
		new TWEEN.Tween(object3d.material.color)
			.to({r: 0.5, g: 0.75, b: 0.25}, 300)
			.easing(TWEEN.Easing.Quartic.EaseIn)
			.start();
	});
	meshes['sphere1'].on('mouseover', function(event){
		var object3d	= event.target;
		if( object3d.rotation.x < Math.PI/4 ){
			var rotation	= {x: Math.PI/2};
			var color	= {r: 1, g: 0.5, b: 0};
		}else{
			var rotation	= {x:0};
			var color	= {r: 0.5, g: 0.75, b: 0.25};
		}
		new TWEEN.Tween(object3d.rotation).to(rotation, 800)
			.easing(TWEEN.Easing.Bounce.EaseOut).start();
		new TWEEN.Tween(object3d.material.color).to(color, 300)
			.easing(TWEEN.Easing.Quartic.EaseIn).start();
	});	

	meshes['sphere3'].on('mouseover', function(event){
		var object3d	= event.target;
		new TWEEN.Tween(object3d.scale)
			.to({x: 1.5, y: 1.5, z: 1.5}, 200)
			.easing(TWEEN.Easing.Quartic.EaseIn)
			.start();
		new TWEEN.Tween(object3d.material.color)
			.to({r: 1, g: 0.5, b: 0}, 600)
			.delay(400)
			.easing(TWEEN.Easing.Quartic.EaseIn)
			.start();
		new TWEEN.Tween(object3d.rotation)
			.to({y: 3*Math.PI}, 1000)
			.easing(TWEEN.Easing.Quartic.EaseIn)
			.start();
	}).on('mouseout', function(event){
		var object3d	= event.target;
		new TWEEN.Tween(object3d.scale)
			.to({x: 1, y: 1, z: 1}, 300)
			.easing(TWEEN.Easing.Quartic.EaseOut)
			.start();
		new TWEEN.Tween(object3d.material.color)
			.to({r: 0.5, g: 0.75, b: 0.25}, 600)
			.delay(400)
			.easing(TWEEN.Easing.Quartic.EaseOut)
			.start();
		new TWEEN.Tween(object3d.rotation)
			.to({y: Math.PI}, 1000)
			.easing(TWEEN.Easing.Quartic.EaseOut)
			.start();
	});
}

	function animate() {
			TWEEN.update();
		requestAnimationFrame( animate );
		renderer.render( scene, camera );
			var time = new Date().getTime();
			var delta = 0.001 * ( time - oldTime );
			oldTime = time;

			uniforms.time.value += 0.275 * delta;

			mesh.rotation.y += 0.5 * delta;
			mesh.rotation.x += 0.1 * delta;
	
	}

	animate();
	</script>
</body>
</html>
